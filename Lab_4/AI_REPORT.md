# AI REPORT
## Lab 04: Event Handling & Reusable Components
### Student Name: Нурканат Алиар
### Lab 4.1: Event Handling — Form & Validation

## 1. Информация об использовании AI 
- **Инструмент:** Google Gemini
- **Дата:** 2026-02-07

## 2. Конкретные промпты

### Промпт 1:
"Объясни требования лабораторной работы 04 по React (Event Handling & Reusable Components)"

**Что получил:** Подробный разбор задач по созданию управляемых форм и рефакторингу монолитного компонента на подкомпоненты.

### Промпт 2:
"Как реализовать валидацию формы в React на лету (on change) для полей Name, Email и Age?"

**Что получил:** Пример кода с использованием `useState` для хранения значений и ошибок, а также логику проверки регулярным выражением для email и условий для возраста (18+).

### Промпт 3:
"Зачем использовать e.preventDefault() в обработчике onSubmit?"

**Что получил:** Объяснение механизма работы синтетических событий в React и предотвращения стандартного поведения браузера (перезагрузки страницы).

## 3. Модификация и проверка
- **Валидация:** Самостоятельно настроил проверку длины имени (минимум 2 символа) и логику очистки полей после успешной отправки.
- **Интерфейс:** Добавил условный рендеринг для вывода сообщения об успешной регистрации ("Registration successful!").
- **Стилизация:** Применил инлайновые стили для отображения ошибок красным цветом, как указано в задании.

## 4. Что узнал
- Понял концепцию **Controlled Components** (управляемых компонентов), где React полностью контролирует значение инпутов.
- Изучил работу с **Synthetic Events** (синтетическими событиями) и их отличия от нативных событий браузера.
- Научился разделять логику ввода данных и логику их валидации.

## 5. Процент использования
- 20% — AI (помощь со структурой обработчиков и регулярным выражением для email).
- 80% — Самостоятельное написание кода на TSX, логика сброса состояния и верстка.

---

### Lab 4.2: Refactoring — Article Management

## 1. Информация об использовании AI
- **Инструмент:** Google Gemini
- **Дата:** 2026-02-07

## 2. Конкретные промпты

### Промпт 1:
"Как правильно разделить один большой компонент ArticleManager на AddArticle, ArticleList и ArticleItem?"

**Что получил:** Стратегию декомпозиции (рефакторинга): какие пропсы передавать вниз и как организовать связь между родителем и детьми.

### Промпт 2:
"Пример переноса состояния открытия статьи (isOpened) из родительского компонента в дочерний ArticleItem на TSX."

**Что получил:** Код компонента `ArticleItem` с собственным хуком `useState`, что позволило каждой статье раскрываться независимо от других.

### Промпт 3:
"Напиши интерфейсы TypeScript для пропсов компонентов ArticleList и AddArticle."

**Что получил:** Определение интерфейсов для объектов статей и функций-обработчиков (например, `onClickRemove: (id: number) => void`).

## 3. Модификация и проверка
- **Типизация:** Добавил интерфейс `Article` в отдельный файл/секцию для переиспользования во всех компонентах.
- **Логика удаления:** Реализовал функцию `handleRemove` в родительском компоненте через метод `.filter()`, чтобы обеспечить иммутабельность состояния.
- **Оптимизация:** Убедился, что `isOpened` стейт находится именно внутри `ArticleItem`, чтобы избежать лишних рендеров всего списка при открытии одной статьи.

## 4. Что узнал
- Освоил процесс **рефакторинга** (Refactoring): разбиение сложного кода на мелкие, тестируемые части.
- Понял, когда нужно "поднимать состояние" (Lifting State Up), а когда лучше оставить его внутри дочернего компонента для повышения производительности.
- Научился передавать функции через пропсы для обратной связи между компонентами.

## 5. Процент использования
- 30% — AI (помощь с типизацией пропсов в TSX и архитектурой разделения компонентов).
- 70% — Самостоятельная сборка приложения, отладка передачи данных и финальное тестирование.